---
metaTitle: Radix Themes 3.0
metaDescription: New layout engine, new dashboard components, and brand color generator
---

# Radix Themes 3.0

<Description>
  New layout engine, new dashboard components, and brand color generator.
</Description>

## Introduction

Radix Themes 3.0 just landed. This release is big leap towards making Radix Themes the best component library for building modern SaaS apps. We’ll present the main highlights in this post. The complete changelog and a migration guide are available in the [release notes](/themes/docs/overview/releases#300).

---

## Brand color generator

Radix Themes comes with almost 30 color scales, each with their own light, dark and alpha variants. Under the hood, the color system is powered by [Radix Colors](/colors).

<Box mt="6" mb="7">
  <ThemesAccentSwatches />
</Box>

Today, we are introducing a color tool to create your own brand palette for Radix Themes. It’s a simple interface that lets you specify a primary color, a gray color, and your page background, which then creates a color configuration to copy-paste into your theme styles.

<Text as="div" align="center" my="6">
  <NextLink href="/colors/create-your-palette">
    <img
      src="https://workos.imgix.net/images/d102af28-90e3-4a7d-8ab9-3b50a7af9c04.png?auto=format&fit=clip&q=80"
      style={{ borderRadius: 'var(--radius-4)', width: '100%' }}
    />
  </NextLink>
  {<a href="/colors/create-your-palette">Create your palette →</a>}
</Text>

---

## New components

Radix Themes 3.0 introduces a number of new components for building dashboards and data-heavy interfaces. They are built and designed with the level of rigor and care that you’ve come to expect from Radix, and as usual, they are accessible to keyboard and screen reader users. Here’s a quick overview of the main highlights.

### Spinner

Spinner is a simple animated loading indicator:

```jsx live=true
<Spinner />
```

In the Radix version, it comes with an intuitive API to conditionally render its children when they are done loading. Consider the following example:

<ThemesBlogPostExampleSpinner />

```jsx
// Inside the button:
<Spinner loading={loading}>
  <CubeIcon />
</Spinner>
```

The implementation looks effortless—the way it should be. Spinner preserves child dimensions while the data is being fetched, so there is no layout shift between the states. This is an ergonomic way to handle loading states in your app because it minimizes the amount of code branching needed in common situations.

### Skeleton

Skeleton is another loading component in this release:

```jsx live=true
<Skeleton>
  <Button radius="full">Button</Button>
</Skeleton>
```

Skeleton has a similar API to Spinner, but it also fully adopts the shape and size of child components, so you can build the skeleton interface using exactly the same layout that you’d use in the real one:

<ThemesBlogPostExampleSkeleton />

### Segmented Control

Segmented Control carries a familiar design for toggle buttons that switch between values:

<ThemesBlogPostExampleSegmentedControl />

Segmented Control packs many details that were crafted to be invisible. For example, a bolder font weight is used on the active item, yet there is no layout shift, and the animation is dialled in so that even the font weight change transitions smoothly. Here’s the same demo slowed down:

<ThemesBlogPostExampleSegmentedControlAnimated />

### Data List

[Data List](/themes/docs/components/data-list) is a component for displaying a list of key-value pairs:

<ThemesBlogPostExampleDataList />

What’s special about Data List? It is a common pattern that is deceptively tricky to get right. We had to put together a [secret page](https://themes-playground-modulz.vercel.app/test-data-list) with all the different layout combinations as we designed for:

- Values of varied length
- Consistent rhythm between mixed height items
- Configurable alignment of the label and value
- Common layout compositions within
- Leading trim

### Reset

Unlike others, [Reset](/themes/docs/components/reset) is an invisible component:

```jsx live=true
<Reset>
  <button>Button</button>
</Reset>
```

Reset removes default browser styles from any HTML tag and sets idiomatic layout defaults so that you can build your custom components on top of it.

In most interfaces, these styles are global and affect the entire app, so that tends to be a compromise between removing as much as possible and retaining common defaults. Reset puts a new spin on the ergonomics of the normalization styles that almost any website needs.

### Radio Cards

[Radio Cards](/themes/docs/components/radio-cards) is a common pattern for picking a single value out of multiple. They are used for visually engaing forms where each options gets more weight compared to a regular radio button:

<ThemesBlogPostExampleArea>
  <Box width="600px">
    <RadioCards.Root defaultValue="1" columns="3">
      <RadioCards.Item value="1">
        <Flex direction="column" width="100%">
          <Text weight="bold">8-core CPU</Text>
          <Text>32 GB RAM</Text>
        </Flex>
      </RadioCards.Item>
      <RadioCards.Item value="2">
        <Flex direction="column" width="100%">
          <Text weight="bold">6-core CPU</Text>
          <Text>24 GB RAM</Text>
        </Flex>
      </RadioCards.Item>
      <RadioCards.Item value="3">
        <Flex direction="column" width="100%">
          <Text weight="bold">4-core CPU</Text>
          <Text>16 GB RAM</Text>
        </Flex>
      </RadioCards.Item>
    </RadioCards.Root>
  </Box>
</ThemesBlogPostExampleArea>

### Checkbox Cards

[Checkbox Cards](/themes/docs/components/checkbox-cards) are similar to Radio Cards, but are used for picking multiple values:

<ThemesBlogPostExampleArea>
  <Box width="600px">
    <CheckboxCards.Root defaultValue={['1']} columns="3">
      <CheckboxCards.Item value="1">
        <Flex direction="column" width="100%">
          <Text weight="bold">A1 Keyboard</Text>
          <Text>US Layout</Text>
        </Flex>
      </CheckboxCards.Item>
      <CheckboxCards.Item value="2">
        <Flex direction="column" width="100%">
          <Text weight="bold">Pro Mouse</Text>
          <Text>Zero-lag wireless</Text>
        </Flex>
      </CheckboxCards.Item>
      <CheckboxCards.Item value="3">
        <Flex direction="column" width="100%">
          <Text weight="bold">Lightning Mat</Text>
          <Text>Wireless charging</Text>
        </Flex>
      </CheckboxCards.Item>
    </CheckboxCards.Root>
  </Box>
</ThemesBlogPostExampleArea>

### Progress

[Progress](/themes/docs/components/progress) is yet another loading component. It can be used to indicate the progress of a task, or use an ambiguous animation to indicate indeterminate progress:

<ThemesBlogPostExampleProgress />

### Tab Nav

[Tab Nav](/themes/docs/components/tab-nav) is a component for navigating to a different view. It complements its lookalike [Tabs](/themes/docs/components/tabs) sibling, but it is built on top of the Navigation Menu primitive which provides screen reader accessibility and keyboard navigation tailored to links.

<ThemesBlogPostExampleTabNav baseUrl="/themes/docs/overview/3.0" />

---

## New layout engine

A new layout engine makes layout components and their props more powerful and easier to use.

Layout components are a cornerstone feature of Radix Themes. There’s just five of them—[Box](/themes/docs/components/box), [Flex](/themes/docs/components/flex), [Grid](/themes/docs/components/grid), [Section](/themes/docs/components/section), and [Container](/themes/docs/components/section). These components are used to separate layout responsibilities from content and interactivity. This is _the_ separation of concerns that makes apps maintainable and easy to reason about, and understanding these principles is key to building interfaces effectively.

In web development, the lines between different elements may be blurry. You can achieve similar results by layering different techniques onto the same building block, and end up with elements that try to do a lot of jobs at the same time, which incurs complexity, maintenance costs, and results in sneaky bugs.

In Radix Themes, every component is designed in such a way that it encourages you to use it just for what it can do really, really well. With that in mind, only layout components provide easy, unrestricted access to manipulate the layout of your interfaces. This is done through layout props, such as padding, width, height, or position, among others.

Layout components and their props are explained in the [Layout guide](/themes/docs/overview/layout).

### Better layout props

Layout components received a number of new layout props. On top of that, the way that layout props accept values has been significantly reworked:

- 9 new props for working with flex and grid layouts
- 4 new props for controlling the dimensions of layout components
- In addition to [space scale values](/themes/docs/theme/spacing), all layout props now accept valid CSS values, including when used with the responsive object syntax.

### Responsive object syntax

In Radix Themes, _responsive object syntax_ is how you build a responsive layout at different breakpoints without leaving the React code where you compose your app itself.

Consider the following piece of code:

```jsx
<Flex width="500px" />
```

This would create a flexbox layout that’s `500px` wide. But what if you wanted to use a different width on mobile? This is possible using the responsive object syntax, where you can specify the value to use at a particular breakpoint:

```jsx
<Flex width={{ initial: '100%', sm: '300px', md: '500px' }} />
```

Now, in addtion to [space scale values](/themes/docs/theme/spacing), layout props will support valid CSS values. For example, `100px`, `50vw`, or even expressions like `calc(100vw - 200px)` can be used at specific breakpoints.

However, does it perform well? Does it work with server components? Well, here’s how the above `<Flex>` element gets actually rendered into the DOM:

```jsx
<div
  style={{ '--width': '100%', '--width-md': '500px', '--width-sm': '300px'; }}
  class="rt-Flex rt-r-w sm:rt-r-w md:rt-r-w"
/>
```

You can see how that the `<Flex>` element was compiled into a combination of utility classes and CSS custom properties. There is no runtime evaluation of the breakpoints, which means the performance is just like vanilla CSS and the component can be rendered on the server.

### The best of both worlds

Altogether, there is 5 layout components with almost 40 props each. Together they form a system that is easy to learn, quick to master, and sets an _incredibly_ high ceiling of what you can achieve with them without leaving the safety of your JSX files.

If you have never used such a system, we’d suggest you give it try. It is a great alternative to Tailwind, which is an incredibly powerful tool originally built for the same purpose—layout. However, today that evolved into an entire styling paradigm that does not discourage you from creating complex styles on the fly, which violates the separation of concerns mentioned earlier.

Radix Themes layout comes with the full power that utility class frameworks may provide for layout, but it’s also type-safe and guides the developer in maintaining a clear boundary with the other pieces of the interface that they are building.

### Standalone layout components

If you want to use _just_ the layout component from Radix Themes, that’s also possible. Just make sure that JavaScript tree-shaking works on your side, and import the layout essentials CSS:

```jsx
import '@radix-ui/themes/layout.css';
```

---

## ESM ecosystem support

Frameworks like Remix and Astro are configured to use ESM by default. In Radix Themes 3.0, we have revisited the way that the library is built and configured to ensure that it is supported in ESM environments out of the box.

Radix Themes distribution is a _hybrid_ ESM/CommonJS package. Depending on your setup, your import resolver will now pick the right version automatically.

### How dual distributions work

To use Radix Themes, you don’t need to understand the problems of the ESM/CommonJS duality. However, read on if you want to know how the hybrid configuration works under the hood. This may be helpful when building your own packages or debugging issues with your dependencies.

When creating a hybrid package, you’ll compile two versions of your code: one for an ESM environment, and one for CommonJS. Most build tools can easily do this. The problems start when you need to “explain” to the target environment which version is which.

There’s a couple of techniques that may be used to indicate whether a module is ESM or CJS:

- Use conditional `package.json` exports field
- Rely on `.mjs` and `.cjs` extensions to indicate ESM or CJS code
- Use the `type` field in your `package.json` to indicate how `.js` files should be interpreted

### The problem with conditional exports

On the surface, the `exports` field in `package.json` seems to be a straightforward solution to the task. Supposedly, you’d compile the code into two directories, and then use the `import` and `require` statements to point to the right version of the code:

```json
{
  "exports": {
    "require": "./dist/cjs/index.js",
    "import": "./dist/esm/index.js"
  }
}
```

You can even add the `types` field to the `exports` field to ensure that TypeScript works correctly:

```json
{
  "exports": {
    "require": {
      "types": "./dist/cjs/index.d.ts",
      "default": "./dist/cjs/index.js"
    },
    "import": {
      "types": "./dist/esm/index.d.ts",
      "default": "./dist/esm/index.js"
    }
  }
}
```

This works fine if all of the package code is bundled into those `index.js` files and there are no internal submodules. It makes sense for a package that would do just one thing, when all of its code can be naturally bundled into a single file.

However, a package like Radix Themes exports many components, and each export must be from a separate file. This requirement makes it possible to tree-shake the package, so that instead of importing the entire library, your build tool may be able to import just the code you used.

This is where the conditional `exports` field fails. Unintuitively, it describes just whether a particular _entry point_ of the package is ESM or CJS. Past the entry point, `.js` files imported within the package will be interpreted according to the `type` field in `package.json`.

### The problem with file extensions

Because `.js` files are ambiguous, `.mjs` and `.cjs` extensions were introduced to explicitly indicate whether code is ESM or CJS.

Supposedly, you’d rename all the `.js` files in the distribution to `.mjs` and `.cjs`. Then, all the `import` and `require` statements inside of the package need to be patched up to point to the right file. It’s doable, but it’s about as fun as it sounds. On top of that, the `.mjs` extension is not as widely supported by certain toolchains, which a quick search for GitHub issues easily confirms.

### The magic of the `type` field

According to [Node.js docs](https://nodejs.org/api/packages.html#type), the `type` field in `package.json` defines whether `.js` files are interpreted as ESM or CJS.

If you piece that together with how conditional exports work and that you may have additional `package.json` files within the internal folders of a package, you can create a hybrid package that works in both ESM and CJS environments. Altogether, here’s what worked for Radix Themes:

- Set the root `package.json` to the explicit `"type": "commonjs"` value
- Add a separate `package.json` to the ESM distribution folder with `"type": "module"` value
- Use the conditional `exports` field to point to the CJS and ESM entry points

This way, the package will work in both ESM and CJS environments. No `.mjs` or `.cjs` extensions are needed, and the package is tree-shakeable.

---

## @Redacted

This is not going to be a part of the post, but could be a useful piece of copy-pasta for the communication around this post

### What is Radix Themes?

Radix Themes is an open source system of opinionated, pre-built components and design tokens that developers use to build React apps. Exceptional component API design and advanced visual design distinguish Radix Themes from other component libraries. It’s easy to get started, and just as easy to maintain a project built with Radix Themes.

{<img src="https://workos.imgix.net/images/bc42caea-bfe8-4e91-b093-1fe3ff771382.png?auto=format&fit=clip&q=80" />}

Radix Themes is customised via [Theme](/themes/docs/theme/overview) configuration, underlying design tokens, and by building your own components on top of the same building blocks that the library itself is built upon. Naturally, WorkOS product UIs use Radix Themes, which makes it battle-tested in a demanding environment with thousands of users.
